计算机图形学 网课笔记
第一堂课
1.光栅化
光栅化就是将三维物体显示在屏幕上
计算机图形学中实时的定义：30fps
2.曲线和曲面
怎么在计算机图形学中表示几何图形。
3.光线追踪
慢，但真实。
图形学中经常做trade-off，即对不同优势之间的取舍。
那么有没有技术可以达到像光线追踪一样真实，又像光栅化一样快？
有的。实时光线追踪。
4.动画/模拟

We learn Graphics not Graphics APIs.


第二堂课
图形学依赖：
基础数学：线性代数，微积分，统计学
基础物理：光学，力学
其他：信号处理，数值分析
一点点美学

线性代数：向量，矩阵
向量（矢量）：方向和大小
向量的单位化
向量的加法
向量的坐标表示
向量的乘法：点乘，可以用来找两个向量之间的夹角；可以找一个向量投影到另一个向量上的值，进而将向量分解为垂直和平行于一个向量的两部分；用于判断向量是同向还是反向，根据结果正负可以判断同向还是反向，以及接近程度。
向量的乘法：叉乘，右手螺旋定则。在用于建立坐标系统的时候很实用。不满足交换律。交换顺序，加上负号。
叉乘在图形学中的应用：判断左与右，判断内与外。
例题：给定三个点ABC，组成一个三角形，给定一个点P，判断P在ABC内部还是外部？
判断：AB与AP叉乘，BC与BP叉乘，CA与CP叉乘是否同号，若同为正或同为负，则在内部；否则，在外部。
此处的正负，应该指的不是数值的正负而方向的正负，即z轴正向或z轴负向。
用向量的叉乘可以定义出垂直的轴，进而可以定义出坐标系。然后将任意的向量分解到坐标轴上。

矩阵：移动，旋转，缩放，错切。
矩阵的乘积：矩阵乘以数，矩阵乘以矩阵。
矩阵乘法无交换律。矩阵满足结合律和分配律。
矩阵和向量的乘法：将向量视为一个列向量。矩阵乘向量可以用于很多对向量的变换。
单位矩阵
矩阵的逆
向量的叉乘可以视作矩阵乘以向量，例如(xa, ya, za) X (xb, yb, zb) = 
{{0, -za, ya},
 {za, 0, -xa},
 {-ya, xa, 0}
}  * (xb, yb, zb)的转置

第三堂课
变换
2D变换
齐次坐标
变换：模型变换，视图变换
二维变换：
1)缩放(Scale)
(x', y') = ((s, 0), (0, s)) * (x, y)，s为缩放的倍数
非均匀缩放：
(x', y') = ((sx, 0), (0, sy)) * (x, y)
反射矩阵（翻转）：
例如：(x', y') = ((-1, 0), (0, 1)) * (x, y)，关于y轴镜像
切变矩阵(Shear Matrix)：
例如：水平方向拉扯，
(x', y') = ((1, a), (0, 1)) * (x, y)，a为水平方向拉扯的最大位移
旋转变换（二维）：
默认，绕着(0, 0)旋转，方向为逆时针方向。
变换矩阵：((cosθ， -sinθ), (sinθ, cosθ))
可以用代入特殊的点比如(0, 1), (1, 0)结合其旋转后的结果，可以得到旋转公式。
线性变换 = 变换矩阵（同纬度的）

齐次坐标：
平移变换：无法直接用变换矩阵来表示
(x', y') = ((a, b), (c, d))(x, y) + (tx, ty)
假如，我们想用一种统一的形式来表示平移变换，就如前面的缩放，旋转等。
通过引入齐次坐标可以做到这一点。
我们增加一个维度(w参数)
对于2D点，我们用(x, y, 1)来表示
对于2D的向量，我们就用(x, y, 0)表示
那么对于平移变换，我们可以用矩阵 * 向量的形式来表示了
(x', y', w') = ((1, 0, tx), (0, 1, ty), (0, 0, 1)) * (x, y, 1) = (x + tx, y + ty, 1)
由于向量具有平移不变性，故向量的表示用(x, y, 0)表示。
此外，由w参数判断点或向量时，我们可以有如下结果：
vector + vector = vector
point - point = vector
point + vector = point
point + point = mid-point（中点）
所以对于加法操作，这个w参数也有意义。
所以在齐次坐标的扩充定义：2D的点(x, y, w)相当于是(x/w, y/w, 1)的点，w≠0
上面这些变换，都可以归为仿射变换：
仿射变换：(x', y') = ((a, b), (c, d)) * (x, y) + (tx, ty)
用齐次坐标，我们的仿射变换可以表示为：
(x', y', 1) = ((a, b, tx), (c, d, ty), (0, 0, 1)) * (x, y, 1)
不过齐次坐标额外引入了一个维度

逆变换：
对应的是变换矩阵的逆矩阵。

组合变换：
比如：旋转 + 平移
复杂的变换可以通过简单的变换组合做到。
且变换的组合顺序很重要。
变换的组合实际上是变换矩阵的乘法。如果我们用n * 1矩阵表示向量，那么需要左乘变换向量你完成变换。变换的组合，即按顺序左乘一个变换矩阵。
这个可以推广：比如仿射变换的序列是A1, A2, ...
那么对应的变换就是An * ... * A2 * A1 * (x, y, 1)
通过矩阵的结合律，我们可以优化性能。

变换的分解：
比如，一个矩形，不绕原点，进行旋转，该怎么变换？
先将矩形绕的点平移到原点，然后旋转，然后再移回去。
这就是变换的分解。
将一个复杂的变换，拆解为基本的变换。

三维变换：
用齐次坐标表示：
3D的点：(x, y, z, 1)
3D的向量：(x, y, z, 0)
一般地，(x, y, z, w)(w != 0)，表示(x / w, y / w, z / w)的三维的点
三维空间的仿射变换：
(x', y', z', 1) = ((a, b, c, tx), (d, e, f, ty), (g, h, i, tz), (0, 0, 0, 1)) * (x, y, z, 1)
对于这个变换矩阵：它的含义是什么？
是先平移呢？还是先线性变换呢？
顺序：先线性变换，再平移。
因为其对应的不用齐次坐标的表示是((a, b, c), (d, e, f), (g, h, i)) * (x, y, z) + (tx, ty, tz)
是先进行线性变换，再平移的。


第四堂课
本节课会有一定的难度。
先复习一下上一堂课：
旋转-θ角度的变换矩阵就是将旋转θ角的矩阵的θ变为-θ。
但是，我们会发现，变换后，旋转-θ角度的变换矩阵恰好是旋转θ角的变换矩阵的转置。
且从含义上，旋转-θ角度与旋转θ角度互为逆操作，因此两个变换矩阵应该互逆。故，旋转θ角的变换矩阵满足其逆矩阵等于其转置矩阵。由定义，这个矩阵是正交矩阵，比较有趣。


三维变换
Viewing（观测）变换：视图变换，投影变换（正交投影，透视投影）

三维变换：
用齐次坐标表示：
3D的点：(x, y, z, 1)
3D的向量：(x, y, z, 0)
一般地，(x, y, z, w)(w != 0)，表示(x / w, y / w, z / w)的三维的点
三维空间的仿射变换：
(x', y', z', 1) = ((a, b, c, tx), (d, e, f, ty), (g, h, i, tz), (0, 0, 0, 1)) * (x, y, z, 1)

三维的变换与二维的变换是非常相似的。
三维的旋转略有不同：
绕x轴旋转α角度：((1, 0, 0, 0), (0, cosα, -sinα, 0), (0, sinα, cosα, 0), (0, 0, 0, 1))
绕y轴旋转α角度：((cosα, 0, sinα, 0), (0, 1, 0, 0), (-sinα, 0, cosα, 0), (0, 0, 0, 1))，略有不整齐，本质上是z叉乘x得到y，而不是x叉乘z得到y，故对于绕y轴的旋转，变换矩阵的cos和sin会反着来。
绕z轴旋转α角度：((cosα, -sinα, 0, 0), (sinα, cosα, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1))
三维的旋转：
Rxyz(α, β, γ) = Rx(α)Ry(β)Rz(γ)
这个角叫做欧拉角。
通过这三个维度的旋转，可以转出任意角度。
将任意的旋转写成变换矩阵：
罗德里格斯旋转公式：
旋转轴n（默认是起点是原点），旋转角度α：
R(n, α) = cos(α)I + (1 - cos(α))nnT + sin(α)((0, -nz, ny), (nz, 0, -nx), (-ny, nx, 0))
任意旋转轴可以通过向量的变换来实现从默认轴的变换
I为单位矩阵。

四元数：在老教材中可能提到，可以用于快速求旋转的差值，比如先转了x角度，又转了y角度，实际相当于变换了多少角度？

Viewing变换：
从三维到二维变换
模型变换（放置模型），视图变换（找个好角度放相机），投影变换（拍照），缩写为MVP变换

视图变换（相机变换）
定义一个相机：位置e，往哪里看g，向上的方向t（用于表示相机自身的旋转，相机顶部的方向）
若物体对相机没有相对运动，那么拍出来的照片是相同的。
为了便于处理，我们假设相机为原点，且为其余所有物体的参考点，即相机永远不动，只有其余物体相对相机的运动。
约定：相机：位置在原点，向上方向为Y，看向的方向为-Z。
然后其他物体相对相机来运动。

将相机从任意位置变换到标准位置：
相机变换的数学实现：
1)将位置e变换到原点（平移变换）
2)将g旋转到-Z（旋转变换）
3)将t旋转到Y（旋转变换）
4)将g X t旋转到X（旋转变换）
（好TM难写啊！）
如何写成一个矩阵：
由于正常的变换矩阵表示的意思是先线性变换，再平移；因此，当我们要先平移的时候，就需要先进行一个平移变换，再线性变换，而不能用一个矩阵直接表示。
Mview = Rview * Tview
Tview = ((1, 0, 0, -xe), (0, 1, 0, -ye), (0, 0, 1, -ze), (0, 0, 0, 1))
由于将任意轴旋转到标准轴不好写，我们可以反过来思考，将标准轴旋转到任意轴，然后再对矩阵求逆。
X轴旋转到(g X t)，Y旋转到t，Z旋转到-g
Rview-1 = ((xgt, xt, x-g, 0), (ygt, yt, y-g, 0), (zgt, zt, z-g, 0), (0, 0, 0, 1))
由于旋转矩阵是正交矩阵，直接将其转置就是其逆。
Rview = ((xgt, ygt, zgt, 0), (xt, yt, zt, 0), (x-g, y-g, z-g, 0), (0, 0, 0, 1))
相机做了如此变换，为了保持相对不变，其余所有物体都要做相同的变换

模型变换经常与视图变换一起使用，叫做模型视图变换。

投影变换：
正交投影
透视投影
正交投影不会带来近大远小的现象，透视投影会近大远小的想象。
在数学上的表示：
透视投影：将镜头视作一个点，然后再空间中与物体上的点连线，形成一个锥体，在这个锥体中，我们取一个截面，这个截面上的东西显示出来。
正交投影：镜头放在无限远，因此，任何距离上的界面都是一样的大小。

正交投影：
我们的镜头放在标准位置，然后可以直接去掉z轴坐标，然后通过变换缩放到[-1, 1]区间内。为什么要变换到[-1, 1]？约定俗成，便于之后的计算。
一般做法：
定义一个空间的立方体[l, r] * [b, t] * [f, n] ： x轴[左，右]， y轴[底，顶]，z轴[远，近]，不过由于我们看的是-Z方向，因此对我们而言的远实际上的值是更小的，近的值是更大的。
映射到规范(canonical)立方体[-1, 1] * [-1, 1] * [-1, 1]
将立方体先移动到中央位置，然后缩放为规范立方体。
变换矩阵：先平移，再缩放
Mortho = ((2 / (r-l), 0, 0, 0), (0, 2 / (t - b), 0, 0), (0, 0, 2 / (n - f), 0), (0, 0, 0, 1)) * ((1, 0, 0, -(r+l) / 2), (0, 1, 0, -(t + b) / 2), (0, 0, 1, -(n+f) / 2), (0, 0, 0, 1))
注意：在OpenGL中，用的是左手系，与这里的不同。

透视投影：
近大远小
平行线不再平行
回顾一下：齐次坐标的定义(x, y, z, 1), (xz, yz, z^2, z)(z != 0)代表的是同一个点。
将远平面“挤”到近平面上，然后再进行一次正交投影，缩放后就是我们的近平面上的投影。
不过在“挤”的过程中，我们需要注意，“挤”的过程中近平面的点z不变，远平面的中心点不变。
Mpersp->ortho, Mortho
挤压后，y' = n / z * y(相似三角形求出，n为近平面与视点的距离，z为远平面与视点的距离)
同理，x' = n / z * x
(x, y, z, 1) => (nx / z, ny / z, unknown, 1)，将这个结果等价乘以z，得到(nx, ny, still unknown, z)
我们可以得到这个变换矩阵中的一部分值。
Mpersp->ortho = ((n, 0, 0, 0), (0, n, 0, 0), (?, ?, ?, ?), (0, 0, 1, 0))
由两个观察事实：近平面上和远平面上的点的z不变，即映射到它自己
所以
(x, y, n, 1) = (nx, ny, n^2, n)
所以对于变换矩阵第三行应该是(0, 0, A, B) * (x, y, n, 1) = n^2，因为n^2与x和y没关系
而远平面的中心点(0, 0, f, 1)映射也是自己，故(0, 0, f, 1)映射后仍是自己，即(0, 0, f^2, f)
因此A * n + B = n^2, A * f + B = f^2
这样就可以得到A和B的值。
A = n + f, B = -nf
综上，从“挤压”变换的变换矩阵就有了。
然后再进行正交变换就得到了透视投影的变换矩阵。

思考题：对于近平面和远平面上面的点，z值不变，那么对于挤压过程中中间的点，他们的z值怎么变？
此外，我们的n和f，即近和远，实际值是n > f，因为我们看向的是z轴负向。
