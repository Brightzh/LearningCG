第五堂课
三角形的光栅化
做完观测矩阵后，所有的物体都在[-1, 1]^3的标准立方体中，下一步该做什么？
下一步就叫做光栅化(Rasterization)。

透视投影转换为正交投影：
如何定义视锥：定义一个宽高比width / height
还需要定义一个垂直可视角度(vertical field of view, fovY)
如何用fovY和width / height来转换l, r, b, t
设近平面的距离为|n|
tan(fovY / 2) = t / |n|
aspect = r / t

MVP之后是什么？
这个规范立方体该画到哪里？屏幕
什么是屏幕？
一个二维数组；
数组的规模：分辨率；
屏幕是一个典型的光栅显示设备
Raster = screen in German
画到屏幕上 = 光栅化
Pixel(Picture Element)
为了便于理解，我们将像素目前视作一个个颜色均匀的小方块。
颜色是红，绿，蓝的混合。
屏幕空间的定义：与参考书略不同。
像素坐标都写为(x, y)的形式，都用整数的形式描述它。
所有的像素为从(0, 0)到(width - 1, height - 1)
像素的中心为(x + 0.5, y + 0.5)
屏幕覆盖的范围是(0, 0)到(width, height)
映射的时候，将z先不管。
将[-1, 1]^2 映射到[0, width] * [0, height]
先拉伸，再平移
Mviewport = ((width / 2, 0, 0, width / 2), (0, height / 2, 0, height / 0), (0, 0, 1, 0), (0, 0, 0, 1))

将多边形打碎成像素————光栅化

示波器，CRT显示器
早期的显示器如何显示画面？
扫描，画线，隔行扫描
显示器通过显卡的内存区域映射到屏幕上，显示的图像实际上就是一块内存区域。

平板显示设备，LCD(Liquid Crystal Display，液晶显示设备)
原理：通过液晶的极化扭曲，屏蔽或通过光线。

LED Array Display
发光二极管

Electrophoretic(Electronic Ink) Display
电子墨水瓶
刷新率低，但看起来很自然。

怎样在屏幕上画东西
三角形的表示能力很强。
三角形是最基础的多边形。任何多边形都可以拆成三角形。
三角形内部一定是平面的。
三角形的内外定义很清晰。其他多边形，若存在孔洞，则判断内外很复杂。
三角形的渐变性很好。即给出了三个点的特性，很容易推理出三角形内的其他位置的特性。

光栅化的最重要问题：判断一个像素的中心点和三角形的位置关系

采样法：
采样是图形学中非常重要的概念。
用像素中心对屏幕空间进行采样。

给定一个三角形，判断像素中心是否在三角形内：
inside(t, x, y) = 1, Point (x, y) in triangle t; 0, not in triangle t

光栅化 = 对一个2D表示函数的采样

for(int x = 0; x < xmax; x ++){
	for(int y = 0; y < ymax; y ++){
		image[x][y] = inside(tri, x + 0.5, y + 0.5);
	}
}

如何判断一个点是否在三角形内，前面已经提到了。
做叉乘就行了。例如判断点P是否在三角形ABC内。判断AB X AP, BC X BP, CA X CP是否z值同号，可以判断出是否在三角形内。

对于点恰好在边上，如何处理？
不做处理，或特殊处理。

Bounding Box，轴向包围盒来判断像素点是否在三角形内。
Axis Aligned Bounding Box(AABB)

实际屏幕的光栅化

思考题：锯齿（Aliasing, Jaggies），抗锯齿（反走样）

第六堂课
反走样和深度缓冲
锯齿，学名叫做走样(Aliasing)。
采样不只可以发生在不同的位置，也可以发生在不同的时间。
采样是广泛存在的。
Artifacts：一切不对头的结果
采样的问题也是广泛存在的。
采样会产生锯齿、摩尔纹（将一张图片的奇数行奇数列去掉，压缩后，再放到原图大小，就会产生摩尔纹）
人眼在时间上的采样也可能会产生错觉，比如车轮转速很快时，看起来像是倒着转。
走样的本质：信号的变化太快，相应地采样太慢，导致走样产生。
反走样：采样前先做一个模糊（滤波，实质上是将奈奎斯特定律算出的最大可表达频率之上的频率都去掉），再采样。

频域
傅里叶级数展开：任何一个周期函数，都可以分解为若干个正弦和余弦函数的和。
傅里叶变换：将函数变为不同频率的段。
而高频率的变换需要更快的采样。
采样不足会产生频率走样。
同样的采样频率采样两种不同频率的函数，得到的结果相同，导致无法区分两者，这就是走样的本质。

滤波 = 将特定频率的内容去掉
傅里叶变换可以从时域变到频域
滤掉低频的部分：只有高频通过，高通滤波
滤掉高频的部分：只有低频通过，低通滤波
滤掉高频和低频的部分：只有中间部分的频率通过。
此部分的内容是在数字图像处理课程中详细讲解。
不过现在很多的图像处理用的是机器学习方法。

滤波 = 卷积（平均）
卷积在图形学中可以视作：Signal（相当于一个向量） 通过 Filter(相当于一个窗口，有不同权重)，滑动这个窗口，将向量中对应的值与权重相乘得到结果。最后得到Result（新的向量）
对于卷积，有两个结论：时域的卷积实际上是频率的乘积。频域的卷积实际上是时域的乘积。
那么，我们对于时域的卷积，可以通过先将信号傅里叶变换到频域上，相乘，然后将结果再用傅里叶逆变换，变回来，实现。

采样 = 重复频域上的内容
采样率不足造成，原始的频域上的内容重复的间隔不够大，会导致一些部分频域的内容互相覆盖，导致走样。
所以，走样 = 混合的频域上的内容

怎样减少走样错误？
方法1：增加采样率
但是这个方法是昂贵的。
方法2：反走样
先做模糊，再做采样。
先将高频信息去掉，然后再采样，这样就减少了频域内容的混叠
所以，反走样 = 限制，然后重复

如何实现反走样？
即，如何实现模糊？如何采样我们已经知道了。
先进行一个卷积操作。将每个像素中的值平均化，求出实际在每个像素中覆盖的面积，然后取平均值，比如实际图形只覆盖了这个1 * 1方格的1/8部分（相当于这1 / 8是纯黑的），那么整个像素就按1 / 8灰度染色，即可实现模糊。
但是实际要计算出每个像素内真实覆盖的面积是困难的。故我们实际实现时会采用一些近似方法。

Multi-Sample Antialiasing(MSAA)
Supersampleing，我们将每个像素再划分为多个小像素，然后数出覆盖的小像素的数量，就可以近似得到实际覆盖的面积的近似值。
MSAA实际上得到近似的覆盖率，便于快速将像素的颜色平均化，实现模糊，然后再采样，实现抗锯齿。

MSAA的代价是什么？
增大了计算量。
但是如何减少计算量？通过特定的不规则的划分像素，实现一些一些划分后的像素的复用，减少计算量。
如何分布样本才能达到最好的覆盖效果？这在光线追踪部分会提到。

其他的抗锯齿方案：
FXAA(Fast Approximate AA)：先将有锯齿的图得到，把有锯齿的边界换为没有锯齿的边界。
TAA(Temporal AA)：找上一帧的信息，复用上一帧的值，相当于将MSAA分布在了时间上。
那么对于运动的物体怎么做？在光线追踪的部分讲。主要会用TAA。

Super resolution / super sampling
将一张小图拉大，但又不想看到锯齿。采样率不够，又想恢复出高分辨率图。
一种做法：DLSS(Deep Learning Super Sampling)，用深度学习猜出缺少信息的部分。

第七堂课
着色(Shading)
光照，着色，图形管线
对于上一堂课，还剩下深度缓存(z-buffering)的内容没有细讲。
可见性，遮挡，近处的挡住远处的

画家算法(Painter's Algorithm)
先将远处的物体画到屏幕，然后再画近处的物体。
但是存在一个问题，如何评估一个物体的远近（深度）
且存在一些情况无法处理。
在深度上存在互相遮挡关系的几个物体，无法排序。

Z-Buffer
目前广泛采用的算法
只记录当前像素中z最小对应的那个值。
利用深度缓存，维护遮挡信息。
注意：由于我们向-z方向看去，实际上如果是负值，应该是z越大越近，z越小越远。
为了简化，我们假设z总是正的，那么z越小越近，z越大越远。
对一个例子的实现（伪代码）：
Initialize depth buffer to ∞
During rasterization:
	for(each triangle T)
		for(each sample (x, y, z) in T)
			if(z < zbuffer[x, y])
				framebuffer[x, y] = rgb;
				zbuffer[x, y] = z
			else
不同位置的深度如何计算？下节课讲
维护像素当前能看到的最浅的结果
Z-Buffer与加入物体的顺序没有关系
几乎所有的光栅化都会做深度测试，得到正确的遮挡算法，几乎在所有GPU都有应用。

可以不对每个像素做深度缓存，而对每个采样点做深度缓存，可以应用到MSAA中。

着色(Shading)：定义，引入明暗和不同的颜色。
在图形学中，着色的定义为将对不同的物体应用不同的材质的过程。
基础的着色模型：Blinn-Phong Reflectance Model
观察光打到物体上的情况：有高光、漫反射和间接光照

shading point在物体表面
输入（由于这些量均表示方向，故均为单位向量）：
观察方向， v
法线，n
光照方向，l
表面参数（颜色，shininess（与亮度不同），...）

着色情况只看局部情况，有局部性，不考虑这里是否在阴影之中。

漫反射：光线均匀反射到各个方向。
但是多少光线会被反射？
这与光线方向和法向的夹角有关。
考虑光是一种能量，考虑物体接收到了多少能量，考虑着色点周围的单位面积内接收到多少能量。
Lambert's余弦定律：接收到的能量与光照方向与法线方向的夹角成正比。
cosθ = l · n，l为光照方向，n为法线方向

Lambertian(Diffuse) Shading
Shading independent of view direction
Ld = kd * (I / r^2) * max(0, n·l)
I为在单位球壳的能量密度，I / r^2为到达shading point的能量。
Kd为漫反射系数(color)
max(0, n·l)为shading point接收到的能量，忽略了折射之类的情况，只考虑反射
Ld为漫反射的光。
颜色实际上是吸收了一部分的能量，反射了一部分能量，颜色是反射出的能量。通过颜色实际上可以转换为一个能量吸收或反射的系数。
漫反射的光应该在各个方向是一样的，故漫反射项与方向无关。


第八堂课

Blinn-Phong折射模型：漫反射、高光、环境光
上一堂课讲了漫反射
高光项：类似镜面反射的部分。
当我们的观察点与shading point接近时，法向量与半程向量是非常接近的。
半程向量h = (v + l) / ||v + l||
Ls = ks * (I / r^2) * max(0, cosα)^p，α为半程向量与法向量的夹角，两者非常接近
Ls = ks * (I / r^2) * max(0, n·h)^p
ks为镜面反射系数
由于，Blinn-Phong模型是经验模型，故不考虑实际吸收的能量，按理说应该要乘以一个光的方向与法向量的夹角的余弦得到实际的反射能量。
之所以用n·h，是因为，它足够接近，而且很好算，直接用反射方向准确算是可以的，但是计算比较麻烦。
之所以余弦上面的指数p，是为了加速高光区域的衰减，这样高光的区域就会比较窄，否则，会有一大片高光，一般取p为100到200

环境光照项(Ambient Term)
La = ka * Ia
这是一个近似公式
相当于让所有的部分多了一点能量，让所有的部分都不至于全黑。
但是这是不准确的。后面，在全局光照部分会有准确的做法。

L = La + Ld + Ls

着色频率
着色频率：着色应用在哪些点上
Flat shading：对每个三角形着色，三角形内部无变化，不太平滑。
Gouraud shading：求出三角形每个顶点的法线，每个顶点着色，三角形内部插值。
Phong shading：对每个像素着色。
如果三角形足够密集，Flat shading也是可用的。三角形的频率够高时，着色频率就不需要那么高。
顶点的法线怎么求？
1)已知模型，那么直接计算就行了
2)对以该顶点邻接的面的法线求平均，即假设该顶点是多个三角形面的一个共同的顶点，将这些三角形面的法线方向求出，然后求平均。
为了更准确，可以加权平均，权重与三角形面积成正比。
像素的法线怎么求？
知道顶点法线，然后通过重心坐标，求出中间像素的法线。后面会细讲。

图形管线(Graphics Pipeline)（实时渲染管线）
从场景到最终的图，中间的过程叫做pipeline
三维空间的点->投影到屏幕上->形成三角形->光栅化->着色->屏幕上的图
这部分操作，在硬件中已经写好了。
MVP变换，相当于做了每个顶点的变换；采样，判断点是否在三角形内，相当于光栅化；Z-Buffer，着色；Shading，在顶点或像素处理部分。
整个这个过程的代码就叫做：Shader
Shader实质上控制顶点和像素的着色。
还有纹理映射的内容，之后会讲。
现代的GPU允许自己编程决定顶点和像素如何操作，如何着色。
如果写的是决定顶点如何操作的，就叫做vertex shader，叫做顶点着色器。
如果写的是关于像素的，就叫做fragment/pixel shader，叫做片段/像素着色器。

随着GPU的发展，显卡可以大量处理几何，并高度并行快速着色。
目标：高度复杂的实时3D场景
比如，虚幻引擎

Graphics Piieline Implementation: GPU
图形管线的硬件实现：GPU
其中有一部分是可编程的。
GPU分为独立显卡和集成显卡。
GPU可以理解为高度并行的处理器，所以特别适合图形学的项目。

纹理映射
我们希望有一种方法可以定义一个物体上任何一个点的属性。相当于之前提到的kd这个系数。
我们定义的是物体表面的点。
纹理上的三角形怎么映射到物体上。
这个映射可以人工（美工），也可以自动化（参数化，几何的前沿研究）。
假设我们已经知道了这个映射关系。
纹理坐标一般用uv表示(u, v是两个坐标轴，uv的范围一般是[0, 1] * [0, 1])
三角形三个顶点，每个顶点都对应一个uv。
纹理可以多次映射到不同的地方。
为了让纹理多次使用且看不出明显的边界，需要设计出tilable texture，这是可以算的，有一种算法叫做Wong tilable texture。无缝衔接的合成。
直到三角形三个顶点的纹理uv？如何求出三角形内部的点的属性。
这用到了重心坐标，下节课细讲。
纹理相当于在着色时，用纹理定义了着色的方式，而不是以一种统一的方式着色。


第九堂课
回顾一下上面的内容：
Blinn-Phong反射模型: 漫反射，高光，环境光效。
顶点折射器，像素折射器
纹理映射

本讲内容：
重心坐标用于插值
纹理如何映射

重心坐标（Barycentric Coordinates）
Interpolation Across Triangles
为什么进行三角形内插值：平滑过渡
插值的内容：纹理映射，颜色，法向量
怎么做插值：重心坐标
重心坐标定义在一个三角形上。
设三角形三个顶点A, B, C已知
三角形内容的点(x, y) = αA + βB + γC
其中α + β + γ = 1
用α, β, γ表示三角形平面上的点。
如果这个点在三角形内部，α, β, γ均大于0。
这就是重心坐标。（相当于一种新的在三角形所在的平面内表示坐标的方式）
这是结论，可以通过数学证明。

求三角形内部的任意一个点，求出其重心坐标。可以通过面积求出。
设P为该点。
α = S(PBC) / S(ABC)
β = S(PAC) / S(ABC)
γ = S(PAB) / S(ABC)
比较容易记忆，恰好是其顶点对面的小三角形的面积。

三角形的重心，其重心坐标为(α, β, γ) = (1/3, 1/3, 1/3)

对于一般的三角形内部的点P，其重心坐标公式如下：
设(x, y)为P的坐标，A, B, C的坐标分别是(xA, yA), (xB, yB), (xC, yC)
则，
α = [-(x - xB)*(yC - yB) + (y - yB)*(xC - xB)] / [-(xA - xB)*(yC - yB) + (yA - yB)*(xC - xB)]
β = [-(x - xC)*(yA - yC) + (y - yC)*(xA - xC)] / [-(xB - xC)*(yA - yC) + (yB - yC)*(xA - xC)]
γ = 1 - α - β

通过重心坐标，其差值为
V = α * VA + β * VB + γ * VC
V, VA, VB, VC可以是任何的同种属性

不过，重心坐标在投影变换下是会变化的。
所以，如果我们如果想在一开始就算差值，需要在投影变换前做插值，即需要找到投影前的坐标，然后再算插值，而并不能直接用投影后的坐标算重心坐标差值。
如何找到投影前的坐标？用投影变换矩阵的逆矩阵即可从投影后的坐标找到投影前的坐标。

在实际渲染中怎么应用纹理
简单纹理映射：Diffuse Color
for each rasterized screen sample (x, y):
	(u, v) = evaluate texture coordinate at (x, y)
	texcolor = texture.sample(u,v);
	set sample's color to texcolor;
但是如果这么简单地映射会出什么问题？
1.纹理放大
如果纹理太小了怎么办？纹理的分辨率不足，该怎么办？
对于任何屏幕上的一个点，我们都可以找到纹理的一个位置，但是由于纹理分辨率不足，找到的对应位置可能不是整数。
我们可以直接取整。找到的对应texel(纹理元素)。但这样不自然。
如果我们想得到稍微连续一点的图。应该如何得到对应位置的值？
双线性差值(Bilinear interpolation)。
找到纹理上映射的位置的邻近的四个点，计算对应位置与左下角的点的相对距离(s, t)。0 <= s, t <= 1
然后我们进行线性插值。
一维的线性差值lerp(x, v0, v1) = v0 + x * (v1 - v0)
我们先对一个方向进行两次一维的线性插值，再对这个值进行一次线性差值。
具体地，u0 = lerp(s, u00, u10), u1 = lerp(s, u01, u11)
f(x, y) = lerp(t, u0, u1)

双线性插值的质量比取整好一些，但是比更高级的方法更差一些。

Bicubic插值，取周围16个点，然后每次用4个点做3次插值。具体细节未讲。

2.纹理过大怎么办？
纹理过大，也会出现问题。
会出现走样问题。
屏幕上的像素覆盖的纹理区域是各不相同的。因为远处的点的覆盖的纹理区域大，近处的相对较小。
超采样可以一定程度解决这个问题，但是这会让问题变得困难。不建议用。
如果不采样，我们可以快速得到区域内的平均值就好了。如何快速地得到平均值？
这个问题本质是个算法问题。这个问题属于点查询问题(Point Query)和范围查询问题(Range Query)。
Mipmap可以做快速地近似地正方形的范围查询。
Mip意思是很多不同的小东西。
Mipmap用一张图生成多张不同层次（不同分辨率）的图。
在图形学中，Mipmap叫做图像金字塔
假设原来的存储量是1，那么用Mipmap引入的额外存储量是多少呢？
等比数列求和，4 / 3，只比原来多了1 / 3
那么我们该如何求映射后的纹理覆盖区域的大小呢？
设层次为D，纹理区域的边长为L。映射前的像素坐标为u， v
那么L = max(sqrt((du/dx)^2 + (dv/dx)^2), sqrt((du/dy)^2 + (dv/dy)^2)), D = log2(L)
算出微分，相当于映射前的坐标周围的面积元，映射到纹理中的面积元的规模。
映射前的一个像素，映射到某层Mipmap，在该层中对应地也是一个区域。
不过直接在不连续的层之间查询，会出现不连续的渐变。为了连续，我们可以找到邻近的两层，然后做层与层之间的插值。
区域内双线性插值，层次与层次之间再做一次差值，这称为三线性插值。

Mipmap是否能完全解决问题
仍存在问题，在远处的部分会出现过于模糊的情况。Overblur
Mipmap主要是用于正方形的近似范围查询。非正方形的情况就会出现问题。

可以部分解决Mipmap不能解决的问题的方法之一：各向异性过滤
Anisotropic Filetring
各向异性过滤多了一些不同比例的压缩情况，即从正方形变为了矩形的区域查询。
各项异性过滤对于非矩形区域的查询仍然存在问题。
各项异性过滤比Mipmap开销更大。
各项异性过滤mx，表示m层。最终开销收敛到原始的3倍

EWA过滤：将不规则的形状拆成多个圆形，多次查询这些圆形的区域。
开销更大。
