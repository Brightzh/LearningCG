Vulkan学习笔记：
前置要求：
1.显卡，记忆可以与Vulkan编译的驱动（NVIDIA, AMD, Intel, Apple Silicon(Or the Apple Ml)）
2.C++经验（熟悉RAII, initializer lists）
3.能支持C++ 17的编译器(Visual Studio 2017+, GCC 7+, 或者 Clang 5+)
4.3D计算机图形学经验

本章节将从对Vulkan的介绍以及Vulkan解决的问题开始。在那之后，我们将看看构成一个三角形所需要的原料。这将给你提供一个接下来的章节的大致图景。我们将以Vulkan API和常规用法结束。 

Vulkan的起源
就像很多之前的图形学API，Vulkan被设计为一个跨平台的基于GPU的抽象。大部分API的问题在于它们设计的时代其图像硬件的特点导致其功能被限制在了可配置的固定功能。开发者必须提供标准格式的点数据，而任凭GPU制造商来决定光照和着色选项。
随着显卡架构的层数，他们开始提供越来越多的可编程功能。不知为何，这些新的功能需要整合到已有API上。这就导致了不够理想的抽象和将开发者的意图由图像驱动端映射到现代图像架构的许多不确定性。因为这些驱动的复杂性，应用开发者还需要应对供应商的不一致性，比如着色器接受的句法。除了这些新特性，过去十年见证了有强大图像硬件的移动设备的涌入。这些移动GPU根据其功耗和空间要求有着不同的架构。一个这样的例子是平铺渲染，让开发者在这个功能上有更多的控制就可以提升性能。另一个限制是，由于这些API都有些年头，其对多线程的支撑比较有限，这却可以导致CPU端的一个瓶颈出现。
Vulkan设计是从现代图形架构开始的，解决了这些问题。它降低了驱动的过高复杂度，允许开发者用更加长的API来明确他们的意图，允许多线程的创建，并并行提交指令。它降低了着色器编译的不一致性，通过转换为一个编译器的标准化字节码。最近，它通过将图像和计算能力联合到一个API中，实现了现代显卡的通用处理能力。

画一个三角形需要什么
我们将浏览一下用一个高性能的Vulkan程序，渲染一个三角形是所有步骤。所有这里介绍的概念，都会在后面的章节详细阐述。这里只是给你一个将所有独立组件串到一起的概览。

第1步，实例和物理设备选择
一个Vulkan应用从通过VkInstance建立Vulkan API开始。通过描述你的应用以及你将用到的所有API拓展，一个实例(instance)得以创建。
在创建了一个实例后，你可以请求Vulkan支持的硬件，并获取一个或多个VkPhysicalDevice来用于操作。你可以请求像VRAM size这样的参数以及设备能力来选择满足需求的设备，比如优先用专用显卡。

第2步，逻辑设备和队列家族
在选择了一个正确的硬件设备后，你需要创建VkDevice(逻辑设备)，你以更加具体地描述你将用哪个VkPhysicalDeviceFeatures，比如多视口渲染和64位浮点数。你也需要明确，你想要用哪种队列家族。大部分在Vulkan上进行的操作，比如“绘制”指令和内存操作，都是通过将它们提交到VkQueue来异步进行的。队列由队列家族分配，每个队列家族在其队列中支持一种特定的操作集合。比如，有专门的队列家族用于图像，计算和内存转移操作。队列家族的可获取性也可以成为物理设备选择的一个区分因子。让一个Vulkan支持的设备不提供任何图像功能也是可能的，不过如今所有Vulkan支持的显卡通常都会支持我们感兴趣的所有队列操作。

第3步，窗口表面和交换链
除非你只对脱离屏幕的渲染感兴趣，你都需要创造一个窗口来显示你渲染的图片。通过原始的平台API或库文件，像GLFW和SDL，可以创建窗口。我们在这个教程中会用GLFW，在下一个章节会讲到。
我们需要额外的2个组件来渲染一个窗口：一个窗口表面(VkSurfaceKHR)和一个交换链(VkSwapchainKHR)。注意到KHR的后缀，表示这些对象是Vulkan拓展的一部分。Vulkan自己的API是平台无关的，这也是为什么我们需要用标准化的窗口系统接口(WSI, Window System Surface)拓展来跟窗口管理器打交道。表面是跨平台的渲染窗口的抽象，通常通过引用本机窗口句柄来实例化，例如Windows上的HWND。幸运的是，GLFW库文件中有一些内置的功能可以解决这些平台相关的细节。
交换链是渲染目标的一个集合。它的基本目的是确保我们正在渲染的图片要与屏幕上正在显示的图片不同。这很重要，因为只有完整的图片才能显示。每次当我们想绘制一帧时，图片就会返回到交换链中在未来某个时间点就会出现在屏幕上。渲染目标的个数和显示到屏幕上完整图片的情况依赖于当下的模式。常见的当下模式是双缓存(vsync)和三缓存。我们在交换链创建那一章节会研究这些。
一些平台允许你直接渲染到显示器上，而不需要通过VK_KHR_display和VK_KHR_display_swapchain与窗口管理器交流。例如，这些允许你创建衣蛾代表整个屏幕的表面，可以用于应用你自己的窗口管理器。

第4步，图像视图和帧缓冲区
绘制一个从交换链中得到的图片，我们需要将它裹进VkImageView和VKFramebuffer中。一个图片视图引用了将要用到的图片的一个特定部分，而一个帧缓冲区引用将用于颜色、深度和模板目标的图片视图。因为交换链中可能有很多不同的图片，我们将提前创建每个图片的图片视图和帧缓冲，并在要绘制的时候选择正确的那个。

第5步，渲染过程
Vulkan中的渲染过程描述了在渲染过程中的图片类型，他们会怎样被使用，它们的内容会被怎样处理。在我们的初始三角形渲染应用中，我们将告诉Vulakn我们会用一个图片作为颜色目标，并且我们想让它被清为纯色，在我们绘制操作之前。一个渲染过程只描述图片的类型，VkFramebuffer将特定的图片与这些槽绑定。

第6步，图像管线
Vulkan中的图像管线由VkPipeline对象创建。它通过VkShaderModule对象描述了显卡的可配置状态，比如视口大小，深度缓存操作和可编程状态。VkShaderModule对象从着色器的字节码中创建。驱动也需要直到管线中要用的渲染目标是哪一个，我们通过引用渲染通道来指定。
Vulkan和已有的API最大的一个区别在于，几乎所有的图像管线中的配置项都要提前设置。这意味着，如果你想换一个不同的着色器或者稍微调整一下顶点分布，你需要整个重新创建图像管线。这意味着你需要提前创建很多个VkPipeline对象，以用于不同的组合来完成你需要的不同渲染操作。只有一些基础的配置，比如视口大小和清理颜色，可以动态改变。所有状态也需要明确的描述，比如没有默认的颜色融合状态。
好处是你做的相当于提前编译而非及时编译，所以驱动可以有很多可优化的机会，而且性能也更容易预测，因为大的状态改变比如切换到不同的图像管线是非常明确的。

第7步，指令池和指令缓存
许多Vulkan中的操作都需要提交到队列中。在被提交前，这些操作需要先记录进VkCommandBuffer。绘制一个简单的三角形，我们需要记录的指令缓存如下：
开始渲染过程
绑定图像管线
画三个顶点
结束渲染过程
因为帧缓存中的图是依赖于交换链给我们的具体的图的，我们需要给每个可能的图片记录一个指令缓存，然后选择那个需要绘制的。另一种办法是每帧都将指令缓存再记录一次，但是这样效率不够高。

第8步，主循环
现在绘制指令已经被裹进了指令缓存，主循环就很直接了。我们先通过vkAcquireNextImageKHR从交换链中获取一张图。我们然后可以给那张图选择合适的指令缓存，并用vkQueueSubmit来执行它。最后，我们将图片返回到交换链，用vkQueuePresentKHR来展示它到屏幕上。
提交到队列的操作是异步执行的。因此我们需要用同步对象，例如semaphores来确保执行顺序的正确。绘制指令缓存执行必须等待图片获取完成，否则就可能出现我们开始渲染的图还在被读取，就显示到了屏幕上。vkQueuePresentKHR的调用需要等待渲染完成，我们可以用第二个semaphore在渲染完成时发出信号。

总结
这个快速的旅程可以让你在画出第一个三角形前对工作有一个基础的理解。真实世界的程序包含更多的步骤，比如分配顶点缓存，创建同一缓存，上传纹理图片，这些会在之后的章节讲到，但我们会从简单的开始，因为Vulkan的学习曲线已经足够陡峭了。注意，我们已经偷懒了，将顶点坐标初始就放到了顶点着色器中，而不是用一个顶点缓存。这是因为管理顶点缓存需要对指令缓存先熟悉一些。

简单讲，绘制一个三角形，我们需要：
创建一个VkInstance
选择一个支持的显卡(VkPhysicalDevice)
创建VkDevice和VkQueue用于绘制和显示
创建一个窗口，窗口表面和交换链
将交换链的图片裹进VkImageView
创建一个渲染过程明确渲染的目标和用法
创建一个帧缓存用于渲染过程
建立图像管线
分配并记录一个指令缓存，且每个交换链中的图片都有一个draw指令
通过获取图片绘制帧，提交正确的绘制指令华露出来，并将图片返回到交换链

步骤很多，但是每个步骤的的目的都会在接下来的章节中得到明确。如果你还对每个步骤和整体程序的关系不太清楚，你需要重新看看这一章。

代码相关：
所有的Vulkan函数，枚举和结构都在vulkan.h头文件中定义，包含在由LunarG开发的Vulkan SDK中。我们将在之后的章节了解安装这个SDK。
函数有一个小写的vk前缀，枚举和结构有一个Vk前缀，枚举值有一个VK_前缀。API大量用到结构体来给函数提供参数。比如一个对象的创建通常遵循如下模式：
VkXXXCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = nullptr;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
if(vkCreateXXX(&createInfo, nullptr, &object) != VK_SUCCESS){
	std::cerr << "failed to create object" << std::endl;
	return false;
}

许多Vulkan中的结构体都要求你在sType成员中明确指定结构的类型。pNext成员可以指向结构的拓展，在这个教程中都是nullptr。创建或销毁对象的函数会有一个VkAllocationCallbacks 的参数，允许你用一个驱动缓存的自定义分配器，在教程中也会用nullptr。
几乎所有的函数都会返回一个VkResult，其值不是VK_SUCCESS就是一个错误码。




































